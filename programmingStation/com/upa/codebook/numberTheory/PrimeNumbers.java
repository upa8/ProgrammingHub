package com.upa.codebook.numberTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class PrimeNumbers {
	int _sieve_size;
	boolean[] bs; // 10^7 should be enough for most cases
	List<Integer> primes = new ArrayList<Integer>(); // compact list of primes
														// in form of
														// vector<int>

	// first part

	void sieve(int upperbound) { // create list of primes in [0..upperbound]
		this._sieve_size = upperbound + 1; // add 1 to include upperbound
		this.bs = new boolean[this._sieve_size];
		Arrays.fill(this.bs, true); // set all bits to 1
		this.bs[0] = this.bs[1] = false; // except index 0 and 1
		for (long i = 2; i < this._sieve_size; i++) {
			if (this.bs[(int) i]) {
				// cross out multiples of i starting from i * i!
				for (long j = i * i; j < this._sieve_size; j += i) {
					this.bs[(int) j] = false;
				}
				this.primes.add((int) i); // also add this vector containing
											// list of primes
			}
		}
	} // call this method in main method

	boolean isPrime(long N) { // a good enough deterministic prime tester
		if (N < this._sieve_size) {
			return this.bs[(int) N]; // O(1) for small primes
		}
		for (int i = 0; i < this.primes.size(); i++) {
			if ((N % this.primes.get(i)) == 0) {
				return false;
			}
		}
		return true; // it takes longer time if N is a large prime!
	} // note: only work for N <= (last prime in vi "primes")^2

	// second part

	List<Integer> primeFactors(long N) { // remember: vi is vector of integers,
											// long is long long
		List<Integer> factors = new ArrayList<Integer>(); // vi `primes'
															// (generated by
															// sieve) is
															// optional
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx); // using PF = 2, 3, 4, ..., is also
											// ok
		while ((N != 1) && ((PF * PF) <= N)) { // stop at sqrt(N), but N can get
												// smaller
			while ((N % PF) == 0) {
				N /= PF;
				factors.add((int) PF);
			} // remove this PF
			PF = this.primes.get(++PF_idx); // only consider primes!
		}
		if (N != 1) {
			factors.add((int) N); // special case if N is actually a prime
		}
		return factors; // if pf exceeds 32-bit integer, you have to change vi
	}

	// third part

	long numPF(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = 0;
		while ((N != 1) && ((PF * PF) <= N)) {
			while ((N % PF) == 0) {
				N /= PF;
				ans++;
			}
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans++;
		}
		return ans;
	}

	long numDiffPF(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = 0;
		while ((N != 1) && ((PF * PF) <= N)) {
			if ((N % PF) == 0) {
				ans++; // count this pf only once
			}
			while ((N % PF) == 0) {
				N /= PF;
			}
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans++;
		}
		return ans;
	}

	long sumPF(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = 0;
		while ((N != 1) && ((PF * PF) <= N)) {
			while ((N % PF) == 0) {
				N /= PF;
				ans += PF;
			}
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans += N;
		}
		return ans;
	}

	long numDiv(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = 1; // start from ans = 1
		while ((N != 1) && ((PF * PF) <= N)) {
			long power = 0; // count the power
			while ((N % PF) == 0) {
				N /= PF;
				power++;
			}
			ans *= (power + 1); // according to the formula
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans *= 2; // (last factor has pow = 1, we add 1 to it)
		}
		return ans;
	}

	long sumDiv(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = 1; // start from ans = 1
		while ((N != 1) && ((PF * PF) <= N)) {
			long power = 0;
			while ((N % PF) == 0) {
				N /= PF;
				power++;
			}
			ans *= ((long) Math.pow(PF, power + 1.0) - 1) / (PF - 1); // formula
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans *= ((long) Math.pow(N, 2.0) - 1) / (N - 1); // last one
		}
		return ans;
	}

	long EulerPhi(long N) {
		int PF_idx = 0;
		long PF = this.primes.get(PF_idx), ans = N; // start from ans = N
		while ((N != 1) && ((PF * PF) <= N)) {
			if ((N % PF) == 0) {
				ans -= ans / PF; // only count unique factor
			}
			while ((N % PF) == 0) {
				N /= PF;
			}
			PF = this.primes.get(++PF_idx);
		}
		if (N != 1) {
			ans -= ans / N; // last factor
		}
		return ans;
	}

	void run() {
		// first part: the Sieve of Eratosthenes
		this.sieve(10000000); // can go up to 10^7 (need few seconds)
		// 10-digits prime
		System.out.printf("%b\n", this.isPrime(2147483647));
		// not a prime, 104729*1299709
		System.out.printf("%b\n", this.isPrime(136117223861L));

		// second part: prime factors
		// slowest, 2147483647 is a prime
		List<Integer> res = this.primeFactors(2147483647);
		for (int i : res) {
			System.out.printf("> %d\n", i);
		}

		res = this.primeFactors(136117223861L); // slow, 2 large pfactors
												// 104729*1299709
		for (int i : res) {
			System.out.printf("# %d\n", i);
		}

		res = this.primeFactors(142391208960L); // faster, 2^10*3^4*5*7^4*11*13
		for (int i : res) {
			System.out.printf("! %d\n", i);
		}

		// res = primeFactors((long)(1010189899 * 1010189899)); // "error"
		// for (vi::iterator i = res.begin(); i != res.end(); i++)
		// System.out.printf("^ %d\n", *i);

		// third part: prime factors variants
		// 2^1 * 5^2 => 3
		System.out.printf("numPF(%d) = %d\n", 50, this.numPF(50));

		// 2^1*5^(2=>2)
		System.out.printf("numDiffPF(%d) = %d\n", 50, this.numDiffPF(50));
		// 2^1 * 5^2 => 2 + 5 + 5 = 12
		System.out.printf("sumPF(%d) = %d\n", 50, this.sumPF(50));
		// 1, 2, 5, 10, 25, 50, Total 6 divisors
		System.out.printf("numDiv(%d) = %d\n", 50, this.numDiv(50));
		// 1 + 2 + 5 +10 +25 + 50 = 93
		System.out.printf("sumDiv(%d) = %d\n", 50, this.sumDiv(50));
		// 20 integers < 50 are relatively prime with 50

		System.out.printf("EulerPhi(%d) = %d\n", 50, this.EulerPhi(50));

	}

	public static void main(String[] args) {
		new PrimeNumbers().run();
	}
}
