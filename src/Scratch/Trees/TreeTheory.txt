				****** TREEE THEORY *******

------------------------------------------------------------------------------------------
Binary Tree : 
	
	********************Types of binary tree ********************** 
------------------------------------------------------------------------------------------
	Online Resource : 
		http://geeksquiz.com/binary-tree-set-3-types-of-binary-tree/
	
	1) Strict Binary Tree
		If every node has either two  . 
	2) Full Binary Tree
		If every leaf node has exactly two children or 0 children 
	3) Complete Binary Tree
		If all leaf nodes are at height H or H-1
		A Binary Tree is complete Binary Tree if all levels are completely filled 
		except possibly the last level and the last level has all keys as left as possible
	4) Balance Binary Tree: 
		A binary tree is balanced if height of the tree is O(Log n) where n is number 
		of nodes. For Example, AVL tree maintain O(Log n) height by making sure that 
		the difference between heights of left and right subtrees is 1. 
		Red-Black trees maintain O(Log n) height by making sure that the number 
		of Black nodes on every root to leaf paths are same and there are no 
		adjacent red nodes. Balanced Binary Search trees are performance wise 
		good as they provide O(log n) time for search, insert and delete .
	5) Degenerated Tree : 
		A tree where every internal node has only 1 child , such trees are performance 
		wise same as linked list .	
	***************************************************************
	**************Enumeration Of Binary Trees**********************
		1) How many different unlabeled tree can be there with n node . 
			T(n) = (2n)!/(n+1)!*n!
			This is called as catalan number . 
			Number of binary trees with n node is also same as that unlabeled trees.
		2) How many different labeled tree can be there with n nodes. 
			T(n) = T(n) = ((2n)!/(n+1)!*n!)*n!
			 
	***************************************************************
	********************Applications of Tree Data Structure *******
		1) Hierarchy 
		2) Router algorithms 
	***************************************************************
	
	
    *******Properties Of Binary Tree*********
    1) In full binary tree , if h is the height of tree then ((2^h+1)-1) is the number
     of nodes in that tree . 
    2) In complete binary tree , 
    	1) Minimum number of nodes are 2^h
    	2) Maximum number of nodes are ((2^h+1)-1)
    3) Number of leaf nodes in full binary tree are 2^h
    4) Number of Null Links (Wasted Pointers) in complete binary tree of 
    	n nodes is n+1
    5) 


1) Tree Traversal Algorithms 
	1) InOrder 
		
		Iterative :
		
		Recursive :
		 
	2) PreOrder
		
		Iterative :
		 
		Recursive :
		 
	3) PostOrder
		
		Iterative :
		 
		Recursive :
		
	4) Level Order
		
		Iterative :
		 
		Recursive :
	5) 
	
	
		  
2) Binary Search Tree 

3) Segment Tree 
4) Fenwik Tree 
5) Red Black Tree
6) Splay Tree
7) Persistent Tree
8) AVL Tree
9) Trie 
10) Suffix Array 
11) Prefix Array 
12) QuadTree
13) Binary Heap 
14) 



Solutions to most Popular Questions  On Tree : 
1) Height Of Tree : 
	Online Source : 
		https://www.youtube.com/watch?v=ZM-sV9zQPEs&index=22&list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu&ab_channel=TusharRoy
		
	Solution in short : 
		public int height(Node root) {
				if (root == null) {
					return 0;
				}
				int leftHeight = this.height(root.left);
				int rightHeight = this.height(root.right);
				return Math.max(leftHeight, rightHeight) + 1;
		}
		
2) Size of tree  : 
		public int size(Node root) {
				if (root == null) {
					return 0;
				}
				int leftSize = this.size(root.left);
				int rightSize = this.size(root.right);
				return (leftSize, leftSize + 1);
		}
		Size of tree means total number trees present in the tree. 
3) Binary Tree Insertion : 
		
		
		public Node addNode(int data, Node head) {
				Node tempHead = head;
				Node n = Node.newNode(data);
				if (head == null) {
					head = n;
					return head;
				}
				Node prev = null;
				while ( head != null ) {
					prev = head;
					if (head.data < data) {
						head = head.right;
					} else {
						head = head.left;
					}
				}
				if (prev.data < data) {
					prev.right = n;
				} else {
					prev.left = n;
				}
				return tempHead;
			}
		
	

		Time complexity : 
			worst case : o(n)
			
		

4) Binary Search Algorithm : 
		 public Node search(Node root, int key){
		        if(root == null){
		            return null;
		        }
		        if(root.data == key){
		            return root;
		        }else if(root.data < key){
		            return search(root.right, key);
		        }else{
		            return search(root.left, key);
		        }
    	}
    	
    	 * Youtube link - https://youtu.be/zm83jPHZ-jA
  
		  Given a binary search tree and a key, return node which has data as this key or return
		  null if no node has data as key.
		  
		  Solution 
		  Since its BST for every node check if root.data is key and if not go either left or
		  right depending on if root.data is greater or less than key
		  
		  Time complexity is O(n) for non balanced BST
		  Time complexity is O(logn) for balanced BST
  
	  Test cases:
	  1) null tree
	  2) Tree with one node and key is that node
	  3) Tree with many nodes and key does not exist
	  4) Tree with many nodes and key exists
	  
5) Root to leaf Sum Binary Tree : 
		Online Resource : 
		https://www.youtube.com/watch?v=Jg4E4KZstFE&list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu&index=17&ab_channel=TusharRoy
		
		public boolean printPath(Node root, int sum, List<Node> path){
	        if(root == null){
	            return false;
	        }
	
	        if(root.left == null && root.right == null){
	            if(root.data == sum){
	                path.add(root);
	                return true;
	            }else{
	                return false;
	            }
	        }
	        if(printPath(root.left, sum-root.data, path) || printPath(root.right, sum - root.data, path)){
	            path.add(root);
	            return true;
	        }
	        return false;
	    }
6)	Is Binary Tree a Binary Search Tree . 
		Online Resources: 
		https://www.youtube.com/watch?v=MILxfAbIhrE&list=PLrmLmBdmIlpv_jNDXtJGYTPNQ2L1gdHxu&index=16&ab_channel=TusharRoy

		    public boolean isBST(Node root){
     			   return isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    		}
    
		    private boolean isBST(Node root, int min, int max){
		        if(root == null){
		            return true;
		        }
		        if(root.data <= min || root.data > max){
		            return false;
		        }
		        return isBST(root.left, min, root.data) && isBST(root.right, root.data, max);
		    }
		    
	There are four methods to solve this problem 
	Geeksforgeeks Link
	http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/
	
	Best approach is , do in-order traversal of the tree , Check whether the sequence found in 
	this traversal is in ascending order or not . No need to store this sequence in 
	an array , just store the previous value and compare it with current value . 
	If current value is greater than previous value then go forward , 
	otherwise return false . 
	
	
7) 




To Do List : 
1) Write all proper output for TreeTraversals 
2) Program for Diameter of Binary Tree
3) Level Order Traversal 
4) Level Order Traversal In Reverse
5) Boundary Traversal 
6) Find Maximum element in Binary Tree with and without recursion . 
7) Give an algorithm for searching an element in Binary Tree with and without recursion 
8) Algorithm to find size of binary tree with and without recursion 
9) Algorithm to delete the tree .
10) Algorithm to find depth and height of tree. 


